================================================================================
АНАЛИЗ STAGE2 ТРОЯНА
================================================================================

ОБЪЕКТ ИССЛЕДОВАНИЯ: ED2D527EA3A55212D09AD5BD6ED5010E
РАЗДЕЛ: Анализ второй стадии выполнения (Stage2)

================================================================================
1. ОБЩАЯ ИНФОРМАЦИЯ О STAGE2
================================================================================

Stage2 представляет собой вторую стадию выполнения трояна, которая загружается
и расшифровывается после успешного выполнения первой стадии (Stage1). В отличие
от Stage1, который содержит основную логику загрузки и инициализации, Stage2
содержит основную полезную нагрузку трояна.

КЛЮЧЕВЫЕ ОСОБЕННОСТИ:
- Stage2 хранится в зашифрованном виде в секции данных
- Использует собственный алгоритм расшифровки с ключом XOR
- Требует релокации адресов перед выполнением
- Выполняется динамически через прямой переход (jmp)

================================================================================
2. ПРОЦЕСС ЗАГРУЗКИ И РАСШИФРОВКИ STAGE2
================================================================================

2.1. ЗАГРУЗКА ЗАШИФРОВАННЫХ ДАННЫХ
------------------------------------

Адрес начала загрузки Stage2: 0x00401719

Код из lst файла:
```
.text:00401719                  mov     [ebp+var_27C], offset unk_410780
.text:00401723                  mov     edx, [ebp+var_27C]
.text:00401729                  push    edx
.text:0040172A                  call    TakeField
.text:0040172F                  add     esp, 4
.text:00401732                  mov     [ebp+var_270], eax
```

АНАЛИЗ:
- Троян получает указатель на зашифрованные данные Stage2 из области памяти
  по адресу 0x410780 (unk_410780)
- Функция TakeField определяет размер зашифрованного блока данных
- Размер сохраняется в переменной [ebp+var_270]

2.2. ВЫДЕЛЕНИЕ ПАМЯТИ ДЛЯ STAGE2
----------------------------------

Адрес: 0x00401738 - 0x00401747

Код из lst файла:
```
.text:00401738                  mov     eax, [ebp+var_270]
.text:0040173E                  push    eax
.text:0040173F                  call    Alloc
.text:00401744                  add     esp, 4
.text:00401747                  mov     [ebp+var_228], eax
```

АНАЛИЗ:
- Выделяется память размером, равным размеру зашифрованного блока Stage2
- Память выделяется через функцию Alloc, которая использует VirtualAllocEx
- Адрес выделенной памяти сохраняется в [ebp+var_228]

2.3. КОПИРОВАНИЕ ЗАШИФРОВАННЫХ ДАННЫХ
--------------------------------------

Адрес: 0x00401771 - 0x00401804

Код из lst файла:
```
.text:00401771 loc_401771:
.text:00401771                  mov     ecx, [ebp+var_26C]
.text:00401777                  cmp     ecx, [ebp+var_270]
.text:0040177D                  jnb     loc_401809
.text:00401783                  mov     edx, [ebp+var_278]
.text:00401789                  push    edx
.text:0040178A                  mov     eax, [ebp+var_238]
.text:00401790                  push    eax
.text:00401791                  call    Min
.text:00401796                  add     esp, 8
.text:00401799                  mov     [ebp+var_280], eax
.text:0040179F                  mov     ecx, [ebp+var_280]
.text:004017A5                  push    ecx
.text:004017A6                  mov     edx, [ebp+var_27C]
.text:004017AC                  add     edx, [ebp+var_22C]
.text:004017B2                  push    edx
.text:004017B3                  mov     eax, [ebp+var_228]
.text:004017B9                  add     eax, [ebp+var_26C]
.text:004017BF                  push    eax
.text:004017C0                  call    Memcpy
```

АНАЛИЗ:
- Зашифрованные данные копируются порциями по 200 байт (0xC8) через цикл
- Используется обфусцированная функция Memcpy (см. раздел 1.3 основного отчета)
- Процесс копирования аналогичен Stage1, но работает с другим блоком данных

2.4. АЛГОРИТМ РАСШИФРОВКИ STAGE2
----------------------------------

Адрес: 0x00401809 - 0x00401887

Код из lst файла:
```
.text:00401809 loc_401809:
.text:00401809                  mov     [ebp+var_21C], 0
.text:00401813                  jmp     short loc_401824

.text:00401815 loc_401815:
.text:00401815                  mov     ecx, [ebp+var_21C]
.text:0040181B                  add     ecx, 4
.text:0040181E                  mov     [ebp+var_21C], ecx

.text:00401824 loc_401824:
.text:00401824                  mov     edx, [ebp+var_21C]
.text:0040182A                  cmp     edx, [ebp+var_270]
.text:00401830                  jnb     short loc_401889
.text:00401832                  mov     eax, [ebp+var_228]
.text:00401838                  add     eax, [ebp+var_21C]
.text:0040183E                  mov     ecx, [eax]
.text:00401840                  add     ecx, [ebp+var_21C]
.text:00401846                  mov     edx, [ebp+var_228]
.text:0040184C                  add     edx, [ebp+var_21C]
.text:00401852                  mov     [edx], ecx
.text:00401854                  mov     eax, [ebp+var_21C]
.text:0040185A                  add     eax, 5FE9h
.text:0040185F                  mov     [ebp+var_274], eax
.text:00401865                  mov     ecx, [ebp+var_228]
.text:0040186B                  add     ecx, [ebp+var_21C]
.text:00401871                  mov     edx, [ecx]
.text:00401873                  xor     edx, [ebp+var_274]
.text:00401879                  mov     eax, [ebp+var_228]
.text:0040187F                  add     eax, [ebp+var_21C]
.text:00401885                  mov     [eax], edx
.text:00401887                  jmp     short loc_401815
```

АНАЛИЗ АЛГОРИТМА РАСШИФРОВКИ:

1. ИНИЦИАЛИЗАЦИЯ:
   - Счетчик [ebp+var_21C] инициализируется нулем
   - Цикл обрабатывает данные по 4 байта (dword)

2. ПЕРВАЯ ОПЕРАЦИЯ (RVA-дешифровка):
   ```
   [data] = [data] + offset
   ```
   - К каждому dword добавляется его смещение в буфере
   - Это типичная операция для расшифровки относительных адресов (RVA)

3. ВТОРАЯ ОПЕРАЦИЯ (XOR-дешифровка):
   ```
   key = offset + 0x5FE9
   [data] = [data] XOR key
   ```
   - Ключ XOR формируется как сумма смещения и константы 0x5FE9
   - Каждый dword расшифровывается уникальным ключом

ОТЛИЧИЯ ОТ STAGE1:
- Stage1 использует константу 0x5FEA для XOR-ключа
- Stage2 использует константу 0x5FE9 для XOR-ключа
- Разница в 1 байт указывает на разные алгоритмы расшифровки

================================================================================
3. РЕЛОКАЦИЯ АДРЕСОВ STAGE2
================================================================================

3.1. ПОДГОТОВКА К РЕЛОКАЦИИ
-----------------------------

Адрес: 0x00401889 - 0x004018B2

Код из lst файла:
```
.text:00401889 loc_401889:
.text:00401889                  mov     ecx, [ebp+var_240]
.text:0040188F                  mov     edx, [ebp+var_228]
.text:00401895                  mov     [ecx], edx
.text:00401897                  push    1700h
.text:0040189C                  mov     eax, [ebp+var_240]
.text:004018A2                  push    eax
.text:004018A3                  mov     ecx, [ebp+var_4]
.text:004018A6                  add     ecx, 300h
.text:004018AC                  push    ecx
.text:004018AD                  call    Memcpy
```

АНАЛИЗ:
- Расшифрованный код Stage2 копируется в область памяти по адресу
  [ebp+var_4] + 0x300
- Копируется 0x1700 (5888) байт данных
- Это подготовка к выполнению релокации адресов

3.2. ФУНКЦИЯ РЕЛОКАЦИИ sub_4011A0
-----------------------------------

Адрес: 0x004018B5 - 0x004018CA

Код из lst файла:
```
.text:004018B5                  mov     edx, [ebp+var_4]
.text:004018B8                  sub     edx, 400000h
.text:004018BE                  push    edx
.text:004018BF                  mov     eax, [ebp+var_4]
.text:004018C2                  push    eax
.text:004018C3                  mov     ecx, [ebp+var_228]
.text:004018C9                  push    ecx
.text:004018CA                  call    sub_4011A0
```

АНАЛИЗ ПАРАМЕТРОВ:
- arg_0 (ecx): Указатель на расшифрованный код Stage2
- arg_4 (eax): Новый базовый адрес для Stage2 ([ebp+var_4])
- arg_8 (edx): Смещение для релокации ([ebp+var_4] - 0x400000)

3.3. АЛГОРИТМ РЕЛОКАЦИИ
------------------------

Адрес функции: 0x004011A0 - 0x00401245

Код из lst файла:
```
.text:004011A0 sub_4011A0      proc near
.text:004011A0                  push    ebp
.text:004011A1                  mov     ebp, esp
.text:004011A3                  sub     esp, 14h

.text:004011A6 loc_4011A6:
.text:004011A6                  mov     eax, [ebp+arg_0]
.text:004011A9                  cmp     dword ptr [eax+4], 0
.text:004011AD                  jz      loc_401242
.text:004011B3                  mov     ecx, [ebp+arg_0]
.text:004011B6                  mov     edx, [ecx+4]
.text:004011B9                  sub     edx, 8
.text:004011BC                  shr     edx, 1
.text:004011BE                  mov     [ebp+var_C], edx
.text:004011C1                  mov     eax, [ebp+arg_0]
.text:004011C4                  add     eax, 8
.text:004011C7                  mov     [ebp+var_10], eax
.text:004011CA                  mov     [ebp+var_4], 0
.text:004011D1                  jmp     short loc_4011DC

.text:004011DC loc_4011DC:
.text:004011DC                  mov     edx, [ebp+var_4]
.text:004011DF                  cmp     edx, [ebp+var_C]
.text:004011E2                  jnb     short loc_401231
.text:004011E4                  mov     [ebp+var_14], 2348DCh
.text:004011EB                  mov     eax, [ebp+var_4]
.text:004011EE                  mov     ecx, [ebp+var_10]
.text:004011F1                  movzx   edx, word ptr [ecx+eax*2]
.text:004011F5                  sar     edx, 0Ch
.text:004011F8                  cmp     edx, 3
.text:004011FB                  jnz     short loc_40122F
.text:004011FD                  mov     eax, [ebp+var_4]
.text:00401200                  mov     ecx, [ebp+var_10]
.text:00401203                  movzx   edx, word ptr [ecx+eax*2]
.text:00401207                  and     edx, 0FFFh
.text:0040120D                  mov     [ebp+var_8], edx
.text:00401210                  mov     eax, [ebp+arg_0]
.text:00401213                  mov     ecx, [ebp+arg_4]
.text:00401216                  add     ecx, [eax]
.text:00401218                  mov     edx, [ebp+var_8]
.text:0040121B                  mov     eax, [ecx+edx]
.text:0040121E                  add     eax, [ebp+arg_8]
.text:00401221                  mov     ecx, [ebp+arg_0]
.text:00401224                  mov     edx, [ebp+arg_4]
.text:00401227                  add     edx, [ecx]
.text:00401229                  mov     ecx, [ebp+var_8]
.text:0040122C                  mov     [edx+ecx], eax
```

АНАЛИЗ АЛГОРИТМА РЕЛОКАЦИИ:

1. СТРУКТУРА ДАННЫХ РЕЛОКАЦИИ:
   - [arg_0] - базовый адрес блока релокации
   - [arg_0+4] - размер блока релокации
   - [arg_0+8] - массив слов (16-битных значений) с информацией о релокациях

2. ОБРАБОТКА БЛОКОВ РЕЛОКАЦИИ:
   - Функция обрабатывает несколько блоков релокации последовательно
   - Каждый блок содержит заголовок (8 байт) и массив записей релокации

3. ОБРАБОТКА ЗАПИСЕЙ РЕЛОКАЦИИ:
   - Каждая запись - 16-битное слово
   - Старшие 4 бита (биты 12-15) определяют тип релокации
   - Тип 3 (IMAGE_REL_BASED_HIGHLOW) означает 32-битную релокацию
   - Младшие 12 бит содержат смещение от базового адреса

4. ПРИМЕНЕНИЕ РЕЛОКАЦИИ:
   ```
   address = base_address + offset
   [address] = [address] + relocation_offset
   ```
   - К адресу по смещению добавляется разница между старым и новым базовым адресом

ЗНАЧЕНИЕ:
Релокация необходима, так как Stage2 может быть загружен по любому адресу в
памяти, а код содержит абсолютные адреса, которые должны быть скорректированы.

================================================================================
4. ВЫПОЛНЕНИЕ STAGE2
================================================================================

4.1. ПОДГОТОВКА К ВЫПОЛНЕНИЮ
------------------------------

Адрес: 0x004018D2 - 0x004018DD

Код из lst файла:
```
.text:004018D2                  mov     ecx, [ebp+var_4]
.text:004018D5                  add     ecx, 10E0h
.text:004018DB                  push    0
.text:004018DD                  jmp     ecx
```

АНАЛИЗ:
- Вычисляется точка входа Stage2: [ebp+var_4] + 0x10E0
- В стек помещается параметр (0)
- Выполняется прямой переход (jmp) на точку входа Stage2

4.2. ТОЧКА ВХОДА STAGE2
------------------------

Адрес точки входа: [выделенная память] + 0x10E0

АНАЛИЗ:
- Stage2 выполняется как отдельный модуль кода
- Точка входа находится на фиксированном смещении от начала расшифрованного кода
- Это указывает на структуру, аналогичную PE-файлу, где точка входа указана
  относительно начала образа

4.3. ПЕРЕДАЧА ПАРАМЕТРОВ
-------------------------

Параметры, передаваемые в Stage2:
- В стеке: значение 0 (возможно, параметр или флаг)
- В памяти: указатель на расшифрованный код Stage2 в [ebp+var_240]
- В памяти: указатель на выделенную область в [ebp+var_4]

================================================================================
5. СРАВНЕНИЕ STAGE1 И STAGE2
================================================================================

5.1. СХОДСТВА
--------------

1. Оба используют одинаковый процесс загрузки:
   - Получение размера через TakeField
   - Выделение памяти через Alloc
   - Копирование данных порциями через Memcpy

2. Оба используют схожий алгоритм расшифровки:
   - RVA-дешифровка (добавление смещения)
   - XOR-дешифровка с ключом на основе смещения

3. Оба требуют обработки данных перед выполнением

5.2. ОТЛИЧИЯ
-------------

1. ИСТОЧНИК ДАННЫХ:
   - Stage1: off_40F004 (адрес 0x40F004)
   - Stage2: unk_410780 (адрес 0x410780)

2. КОНСТАНТА XOR-КЛЮЧА:
   - Stage1: 0x5FEA
   - Stage2: 0x5FE9

3. РАЗМЕР КОПИРУЕМЫХ ДАННЫХ:
   - Stage1: определяется динамически через TakeField
   - Stage2: определяется динамически через TakeField, но копируется
     фиксированный блок 0x1700 байт перед релокацией

4. ОБРАБОТКА ПЕРЕД ВЫПОЛНЕНИЕМ:
   - Stage1: выполняется напрямую после расшифровки
   - Stage2: требует релокации адресов через sub_4011A0

5. ТОЧКА ВХОДА:
   - Stage1: начало функции start (0x00401410)
   - Stage2: вычисляется динамически как [base] + 0x10E0

================================================================================
6. ФУНКЦИОНАЛЬНОСТЬ STAGE2
================================================================================

6.1. ПРЕДПОЛАГАЕМАЯ ФУНКЦИОНАЛЬНОСТЬ
--------------------------------------

На основе анализа процесса загрузки и выполнения можно предположить, что Stage2
содержит:

1. ОСНОВНУЮ ПОЛЕЗНУЮ НАГРУЗКУ:
   - Stage2 является основной частью трояна
   - Содержит реальную вредоносную функциональность
   - Выполняется только после успешной инициализации Stage1

2. СКРЫТИЕ ОТ АНАЛИЗА:
   - Разделение на стадии усложняет статический анализ
   - Stage2 зашифрован и не виден в исходном файле
   - Релокация адресов делает анализ динамическим кодом сложнее

3. МОДУЛЬНОСТЬ:
   - Stage2 может быть заменен без изменения Stage1
   - Позволяет обновлять функциональность трояна
   - Упрощает распространение разных версий

6.2. ТЕХНИКИ СКРЫТИЯ
---------------------

1. ШИФРОВАНИЕ:
   - Stage2 хранится в зашифрованном виде
   - Используется двухэтапная расшифровка (RVA + XOR)
   - Ключ зависит от позиции данных

2. РЕЛОКАЦИЯ:
   - Адреса корректируются во время выполнения
   - Затрудняет статический анализ
   - Позволяет загружать Stage2 по любому адресу

3. ДИНАМИЧЕСКОЕ ВЫПОЛНЕНИЕ:
   - Код выполняется через прямой переход (jmp)
   - Нет явных вызовов функций из основного кода
   - Усложняет трассировку выполнения

================================================================================
7. ВЫВОДЫ
================================================================================

7.1. ОСНОВНЫЕ НАХОДКИ
----------------------

1. Stage2 представляет собой зашифрованный модуль кода, который загружается
   и выполняется после успешной инициализации Stage1.

2. Процесс загрузки включает:
   - Получение размера зашифрованных данных
   - Выделение памяти
   - Копирование зашифрованных данных
   - Двухэтапную расшифровку (RVA + XOR)
   - Релокацию адресов
   - Выполнение через прямой переход

3. Алгоритм расшифровки использует:
   - RVA-дешифровку (добавление смещения)
   - XOR-дешифровку с ключом (смещение + 0x5FE9)

4. Релокация адресов необходима для корректного выполнения Stage2, так как
   он может быть загружен по любому адресу в памяти.

7.2. ЗНАЧЕНИЕ ДЛЯ АНАЛИЗА
--------------------------

1. Понимание процесса загрузки Stage2 позволяет:
   - Извлечь расшифрованный код Stage2 для дальнейшего анализа
   - Понять структуру данных трояна
   - Разработать инструменты для автоматической расшифровки

2. Анализ алгоритма расшифровки позволяет:
   - Создать скрипт для расшифровки Stage2 без выполнения трояна
   - Изучить полезную нагрузку статически
   - Понять полную функциональность трояна

3. Изучение релокации позволяет:
   - Понять структуру Stage2
   - Восстановить корректные адреса для анализа
   - Создать полный образ Stage2 для дизассемблирования

7.3. РЕКОМЕНДАЦИИ ПО ДАЛЬНЕЙШЕМУ АНАЛИЗУ
-----------------------------------------

1. ДИНАМИЧЕСКИЙ АНАЛИЗ:
   - Использовать отладчик (x64dbg) для трассировки выполнения Stage2
   - Сохранить дамп памяти после расшифровки Stage2
   - Проанализировать функциональность Stage2 в изоляции

2. СТАТИЧЕСКИЙ АНАЛИЗ:
   - Создать скрипт для расшифровки Stage2
   - Загрузить расшифрованный Stage2 в IDA Pro
   - Проанализировать структуру и функциональность

3. ИЗВЛЕЧЕНИЕ ДАННЫХ:
   - Извлечь зашифрованные данные Stage2 из файла
   - Применить алгоритм расшифровки
   - Применить релокацию для получения корректного образа

================================================================================
ПРИЛОЖЕНИЯ
================================================================================

КЛЮЧЕВЫЕ АДРЕСА:
- Начало загрузки Stage2: 0x00401719
- Начало расшифровки: 0x00401809
- Функция релокации: 0x004011A0
- Точка выполнения: 0x004018DD

КЛЮЧЕВЫЕ ДАННЫЕ:
- Источник зашифрованных данных: unk_410780 (0x410780)
- Константа XOR-ключа: 0x5FE9
- Смещение точки входа: 0x10E0
- Размер копируемого блока: 0x1700

АЛГОРИТМ РАСШИФРОВКИ (псевдокод):
```
for offset = 0 to size step 4:
    data[offset] = data[offset] + offset  // RVA-дешифровка
    key = offset + 0x5FE9
    data[offset] = data[offset] XOR key   // XOR-дешифровка
```

================================================================================
КОНЕЦ АНАЛИЗА STAGE2
================================================================================


